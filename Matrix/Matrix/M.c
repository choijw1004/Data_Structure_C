행렬

행렬도 다항식과 마찬가지로 순차자료구조로 나타낼수 있습니다.또, 다항식과 마찬가지로 희소 행렬을 염두해 두고 설계를 하지 않으면, 메모리가 많이 낭비 될 수 있습니다.행렬에서도 다항식과 마찬가지로 2차원 배열을 활용하여, 0이 아닌 원소들의 <행 번호, 열 번호, 값>의 쌍을 이용해 구현합니다. 2차원 배열의 맨 처음 행 즉, [0]번 째 행에는 전체 행렬의 행의 개수와 열의 개수, 0이 아닌 원소의 개수를 입력하여, 행렬에 대한 정보를 저장합니다.나머지는 위에서 구한 <행 번호, 열 번호, 값>을 각 행과 열에 맞게 넣어주면 됩니다.





희소 행렬의 전치 연산

희소 행렬 A = { 0, 5, 3, 0 }

{0, 0, 0, 4}



0이 아닌 원소들의 <행 번호, 열 번호, 값> -> <2, 4, 3>

나머지 원소들 -> <0, 1, 5>

<0, 2, 3>

<1, 3, 4>



예제 소스

#include <stdio.h>



typedef struct {

    int row;

    int col;

    int value;

} term;



void smTranspose(term a[], term b[]) {

    int m, n, v, i, j, p;



    m = a[0].row; //희소 행렬 a의 행 수

    n = a[0].col; //희소 행렬 a의 열 수

    v = a[0].value; //희소 행렬 a에서 0이 아닌 원소 수

    b[0].row = n; //전치 행렬 b의 행 수

    b[0].col = m; //전치 행렬 b의 열 수

    b[0].value = v; //전치 행렬 b의 원소 수



    if (v > 0) { //0이 아닌 원소가 있는 경우에만 전치 연산 수행

        printf("%d %d %d\n", b[0].row, b[0].col, b[0].value);

        p = 1;

        for (i = 0; i < n; i++) { //희소 행렬 a의 열별로 전치 반복 수행

            for (j = 0; j <= v; j++) {//0이 아닌 원소 수에 대해서만 반복 수행

                if (a[j].col == i) {

                    //현재의 열에 속하는 원소가 있으면 b에 삽입

                    b[p].row = a[j].col;

                    b[p].col = a[j].row;

                    b[p].value = a[j].value;



                    printf("%d %d %d\n", b[p].row, b[p].col, b[p].value);



                    p++;

                }

            }

        }

    }

}



void main() {

    term a[] = { {2,4,3},

    {0,1,5},

    {0,2,3},

    {1,3,4} };



    term b[] = { {0,0,0},

    {0,0,0},

    {0,0,0},

    {0,0,0} };



    smTranspose(a, b);



    getchar();

}